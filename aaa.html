<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>æŠ¬æ‰‹æ£€æµ‹API</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #111;
      color: #0f0;
      font-family: 'Courier New', monospace;
      line-height: 1.6;
      padding: 20px;
      min-height: 100vh;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      border-bottom: 2px solid #0f0;
    }
    
    h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
      text-shadow: 0 0 10px #0f0;
    }
    
    .subtitle {
      color: #8f8;
      font-size: 1.1em;
    }
    
    .main-content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-bottom: 30px;
    }
    
    @media (max-width: 768px) {
      .main-content {
        grid-template-columns: 1fr;
      }
    }
    
    .video-section, .controls-section {
      background: rgba(0, 30, 0, 0.3);
      padding: 20px;
      border-radius: 10px;
      border: 1px solid #0f0;
    }
    
    .video-container {
      position: relative;
      width: 100%;
      max-width: 100%;
    }
    
    video {
      display: block;
      width: 100%;
      border: 2px solid #0f0;
      border-radius: 8px;
      background: #000;
      transform: scaleX(-1);
    }
    
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 12px;
      margin-bottom: 25px;
    }
    
    button {
      padding: 12px 20px;
      background: linear-gradient(45deg, #0f0, #0a0);
      color: #000;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      font-family: 'Courier New', monospace;
      transition: all 0.3s ease;
      border: 1px solid #0f0;
    }
    
    button:hover {
      background: linear-gradient(45deg, #0f0, #0f0);
      box-shadow: 0 0 15px #0f0;
      transform: translateY(-2px);
    }
    
    button:disabled {
      background: #333;
      color: #666;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .status-panel {
      background: rgba(0, 20, 0, 0.5);
      padding: 20px;
      border-radius: 8px;
      border: 1px solid #0f0;
      margin-bottom: 20px;
    }
    
    .status-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      padding: 8px;
      background: rgba(0, 40, 0, 0.3);
      border-radius: 4px;
    }
    
    .status-label {
      font-weight: bold;
      color: #8f8;
    }
    
    .status-value {
      color: #0f0;
    }
    
    .hands-info {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-top: 15px;
    }
    
    .hand-panel {
      background: rgba(0, 50, 0, 0.3);
      padding: 15px;
      border-radius: 6px;
      border: 1px solid #0f0;
    }
    
    .hand-title {
      text-align: center;
      font-weight: bold;
      margin-bottom: 10px;
      color: #8f8;
    }
    
    .gesture-display {
      font-size: 2em;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .logs-section {
      grid-column: 1 / -1;
      background: rgba(0, 30, 0, 0.3);
      padding: 20px;
      border-radius: 10px;
      border: 1px solid #0f0;
      margin-top: 20px;
    }
    
    .log-container {
      height: 200px;
      overflow-y: auto;
      background: #000;
      border: 1px solid #0f0;
      border-radius: 6px;
      padding: 15px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }
    
    .log-entry {
      margin-bottom: 8px;
      padding: 5px;
      border-left: 3px solid #0f0;
      padding-left: 10px;
    }
    
    .config-panel {
      background: rgba(0, 20, 0, 0.5);
      padding: 20px;
      border-radius: 8px;
      border: 1px solid #0f0;
      margin-top: 20px;
    }
    
    .config-item {
      margin-bottom: 15px;
    }
    
    .config-label {
      display: block;
      margin-bottom: 5px;
      color: #8f8;
      font-weight: bold;
    }
    
    input[type="range"] {
      width: 100%;
      height: 8px;
      background: #333;
      border-radius: 4px;
      outline: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      background: #0f0;
      border-radius: 50%;
      cursor: pointer;
    }
    
    .config-value {
      text-align: right;
      color: #0f0;
      font-weight: bold;
    }
    
    .gesture-info {
      background: rgba(0, 40, 0, 0.5);
      padding: 15px;
      border-radius: 6px;
      margin-top: 15px;
      border: 1px solid #0f0;
    }
    
    footer {
      text-align: center;
      margin-top: 40px;
      padding: 20px;
      border-top: 1px solid #0f0;
      color: #8f8;
      font-size: 0.9em;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>ğŸ¯ æŠ¬æ‰‹æ£€æµ‹ API</h1>
      <div class="subtitle">ä¸“æ³¨æŠ¬æ‰‹åŠ¨ä½œè¯†åˆ«</div>
    </header>

    <div class="main-content">
      <div class="video-section">
        <h2>ğŸ“¹ å®æ—¶æ£€æµ‹ç”»é¢</h2>
        <div class="video-container">
          <video id="v" autoplay playsinline></video>
          <canvas id="c"></canvas>
        </div>
        
        <div class="hands-info">
          <div class="hand-panel">
            <div class="hand-title">å·¦æ‰‹</div>
            <div class="gesture-display" id="leftHandIndicator">ğŸŸ¡ æœªæ£€æµ‹</div>
          </div>
          <div class="hand-panel">
            <div class="hand-title">å³æ‰‹</div>
            <div class="gesture-display" id="rightHandIndicator">ğŸŸ¡ æœªæ£€æµ‹</div>
          </div>
        </div>
      </div>

      <div class="controls-section">
        <h2>âš™ï¸ æ§åˆ¶é¢æ¿</h2>
        
        <div class="controls">
          <button onclick="GestureAPI.start()" id="startBtn">ğŸš€ å¼€å§‹æ£€æµ‹</button>
          <button onclick="GestureAPI.stop()" id="stopBtn" disabled>ğŸ›‘ åœæ­¢æ£€æµ‹</button>
          <button onclick="GestureAPI.toggleDebug()" id="debugBtn">ğŸ› è°ƒè¯•æ¨¡å¼</button>
          <button onclick="clearLogs()">ğŸ—‘ï¸ æ¸…ç©ºæ—¥å¿—</button>
        </div>

        <div class="status-panel">
          <h3>ğŸ“Š ç³»ç»ŸçŠ¶æ€</h3>
          <div class="status-item">
            <span class="status-label">æ£€æµ‹çŠ¶æ€:</span>
            <span class="status-value" id="statusValue">æœªå¯åŠ¨</span>
          </div>
          <div class="status-item">
            <span class="status-label">æ£€æµ‹æ‰‹æ•°:</span>
            <span class="status-value" id="handsValue">0/2</span>
          </div>
          <div class="status-item">
            <span class="status-label">è¿è¡Œæ—¶é—´:</span>
            <span class="status-value" id="uptimeValue">0s</span>
          </div>
        </div>

        <div class="config-panel">
          <h3>ğŸ›ï¸ è¯†åˆ«å‚æ•°</h3>
          <div class="config-item">
            <label class="config-label">æŠ¬æ‰‹çµæ•åº¦: <span id="liftThValue">0.08</span></label>
            <input type="range" id="liftTh" min="0.03" max="0.2" step="0.01" value="0.08" onchange="updateConfig()">
            <div class="config-value">å€¼è¶Šå°è¶Šçµæ•</div>
          </div>
          <div class="config-item">
            <label class="config-label">æ‰‹åŠ¿ä¿æŒ: <span id="gestureHoldValue">2000</span>ms</label>
            <input type="range" id="gestureHold" min="1000" max="5000" step="500" value="2000" onchange="updateConfig()">
            <div class="config-value">æ‰‹åŠ¿çŠ¶æ€ä¿æŒæ—¶é—´</div>
          </div>
        </div>

        <div class="gesture-info">
          <h4>ğŸ’¡ è¯†åˆ«è¯´æ˜</h4>
          <p><strong>æŠ¬æ‰‹è¯†åˆ«</strong>: æ£€æµ‹æ‰‹éƒ¨ä¸Šä¸‹ç§»åŠ¨</p>
          <p><strong>çŠ¶æ€ä¿æŒ</strong>: æŠ¬æ‰‹çŠ¶æ€æŒç»­æ˜¾ç¤º</p>
        </div>
      </div>
    </div>

    <div class="logs-section">
      <h2>ğŸ“ è¿è¡Œæ—¥å¿—</h2>
      <div class="log-container" id="logContainer"></div>
    </div>

    <footer>
      <p>ğŸ’¡ æç¤º: ä¸“æ³¨æŠ¬æ‰‹åŠ¨ä½œè¯†åˆ«</p>
    </footer>
  </div>

  <script>
    // æŠ¬æ‰‹æ£€æµ‹ API
    const GestureAPI = {
      config: {
        DEBUG: false,
        LIFT_TH: 0.08,           // æŠ¬æ‰‹çµæ•åº¦
        GESTURE_HOLD_TIME: 2000, // æ‰‹åŠ¿ä¿æŒæ—¶é—´
        maxNumHands: 2,
        minDetectionConfidence: 0.7
      },

      state: {
        isRunning: false,
        lastHandData: {},
        camera: null,
        hands: null,
        startTime: 0,
        handCount: 0,
        hasJumped: false // æ ‡è®°æ˜¯å¦å·²è·³è½¬ï¼Œé¿å…é‡å¤è·³è½¬
      },

      callbacks: {
        onLift: null,
        onLiftEnd: null,
        onHandDetected: null,
        onHandLost: null,
        onError: null
      },

      elements: {
        video: document.getElementById('v'),
        canvas: document.getElementById('c'),
        ctx: null,
        log: document.getElementById('logContainer')
      },

      start: async function() {
        if (this.state.isRunning) {
          this._log('æ£€æµ‹å·²åœ¨è¿è¡Œä¸­', 'warning');
          return;
        }

        try {
          this._log('æ­£åœ¨å¯åŠ¨æŠ¬æ‰‹æ£€æµ‹...', 'info');
          await this._initializeCamera();
          await this._initializeHands();
          this.state.isRunning = true;
          this.state.startTime = performance.now();
          this.state.lastHandData = {};
          this.state.hasJumped = false; // é‡ç½®è·³è½¬çŠ¶æ€
          
          this._updateUI();
          this._log('ğŸ‰ æŠ¬æ‰‹æ£€æµ‹å·²å¯åŠ¨æˆåŠŸ', 'success');
          this._log('ğŸ‘‹ æŠ¬æ‰‹è¯†åˆ«ï¼šæ£€æµ‹æ‰‹éƒ¨ä¸Šä¸‹ç§»åŠ¨', 'info');
          this._triggerCallback('onHandDetected', { action: 'system', message: 'æ£€æµ‹å¯åŠ¨' });
        } catch (error) {
          this._log('âŒ å¯åŠ¨å¤±è´¥: ' + error.message, 'error');
          this._triggerCallback('onError', { error: error });
        }
      },

      stop: function() {
        if (!this.state.isRunning) return;

        if (this.state.camera) {
          this.state.camera.stop();
        }
        if (this.elements.video.srcObject) {
          this.elements.video.srcObject.getTracks().forEach(track => track.stop());
        }
        
        this.state.isRunning = false;
        this.state.lastHandData = {};
        this.state.handCount = 0;
        
        this._updateUI();
        this._resetHandDisplays();
        this._log('ğŸ›‘ æŠ¬æ‰‹æ£€æµ‹å·²åœæ­¢', 'warning');
        this._triggerCallback('onHandLost', { action: 'system', message: 'æ£€æµ‹åœæ­¢' });
      },

      on: function(eventName, callback) {
        if (this.callbacks.hasOwnProperty(eventName)) {
          this.callbacks[eventName] = callback;
        }
        return this;
      },

      setConfig: function(newConfig) {
        Object.assign(this.config, newConfig);
        if (this.state.hands) {
          this.state.hands.setOptions({
            maxNumHands: this.config.maxNumHands,
            modelComplexity: 1,
            minDetectionConfidence: this.config.minDetectionConfidence
          });
        }
        this._updateConfigDisplay();
        this._log(`é…ç½®å·²æ›´æ–°: æŠ¬æ‰‹çµæ•åº¦=${this.config.LIFT_TH}`, 'info');
        return this;
      },

      toggleDebug: function() {
        this.config.DEBUG = !this.config.DEBUG;
        this._log('è°ƒè¯•æ¨¡å¼: ' + (this.config.DEBUG ? 'å¼€å¯' : 'å…³é—­'), 'info');
      },

      // å†…éƒ¨æ–¹æ³•
      _initializeCamera: function() {
        return new Promise((resolve, reject) => {
          navigator.mediaDevices.getUserMedia({ 
            video: { 
              facingMode: 'user',
              width: { ideal: 640 },
              height: { ideal: 480 }
            } 
          }).then(stream => {
            this.elements.video.srcObject = stream;
            this.elements.video.onloadedmetadata = () => {
              this.elements.canvas.width = this.elements.video.videoWidth;
              this.elements.canvas.height = this.elements.video.videoHeight;
              this.elements.ctx = this.elements.canvas.getContext('2d');
              resolve();
            };
          }).catch(reject);
        });
      },

      _initializeHands: function() {
        return new Promise((resolve) => {
          const script = document.createElement('script');
          script.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.min.js';
          script.onload = () => {
            this.state.hands = new Hands({
              locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`
            });

            this.state.hands.setOptions({
              maxNumHands: this.config.maxNumHands,
              modelComplexity: 1,
              minDetectionConfidence: this.config.minDetectionConfidence
            });

            this.state.hands.onResults(this._onResults.bind(this));

            const cameraScript = document.createElement('script');
            cameraScript.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.min.js';
            cameraScript.onload = () => {
              this.state.camera = new Camera(this.elements.video, {
                onFrame: async () => {
                  if (this.state.isRunning) {
                    await this.state.hands.send({ image: this.elements.video });
                  }
                },
                width: this.elements.canvas.width,
                height: this.elements.canvas.height
              });

              this.state.camera.start();
              resolve();
            };
            document.head.appendChild(cameraScript);
          };
          document.head.appendChild(script);
        });
      },

      _onResults: function(results) {
        if (!this.elements.ctx) return;

        this.elements.ctx.clearRect(0, 0, this.elements.canvas.width, this.elements.canvas.height);
        this._resetHandDisplays();

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
          const now = performance.now();
          this.state.handCount = results.multiHandLandmarks.length;

          results.multiHandLandmarks.forEach((landmarks, index) => {
            const handedness = results.multiHandedness && results.multiHandedness[index] 
              ? results.multiHandedness[index].label 
              : 'Unknown';
            
            const correctedHandedness = this._correctHandedness(handedness);
            const handId = correctedHandedness;

            if (!this.state.lastHandData[handId]) {
              this.state.lastHandData[handId] = { 
                lastWy: -1, 
                lastTime: 0,
                gestureState: 'open',
                gestureStartTime: 0,
                lastGestureTime: 0,
                liftDirection: null
              };
            }

            const handData = this.state.lastHandData[handId];
            const handColor = correctedHandedness === 'Left' ? '#0ff' : '#f0f';
            const currentTime = performance.now();

            // æŠ¬æ‰‹æ£€æµ‹
            const wristY = landmarks[0].y;
            let isLiftNow = false;
            let liftDirection = null;
            
            if (handData.lastWy >= 0) {
              const deltaY = wristY - handData.lastWy;
              const absDeltaY = Math.abs(deltaY);
              const deltaTime = now - handData.lastTime;
              
              if (absDeltaY > this.config.LIFT_TH && deltaTime < 1000) {
                isLiftNow = true;
                liftDirection = deltaY < 0 ? 'up' : 'down';
                handData.liftDirection = liftDirection;
              }
            }

            // æ‰‹åŠ¿çŠ¶æ€ç®¡ç†
            const timeSinceLastGesture = currentTime - handData.lastGestureTime;
            const shouldKeepGesture = timeSinceLastGesture < this.config.GESTURE_HOLD_TIME;

            if (isLiftNow) {
              // æŠ¬æ‰‹çŠ¶æ€
              handData.lastGestureTime = currentTime;
              
              if (handData.gestureState !== 'lift') {
                handData.gestureStartTime = currentTime;
                handData.gestureState = 'lift';
                this._updateHandDisplay(correctedHandedness, `ğŸ‘‹ æŠ¬æ‰‹${liftDirection === 'up' ? 'â†‘' : 'â†“'}`, handColor);
                this._triggerCallback('onLift', {
                  gesture: 'hand_lift',
                  handedness: correctedHandedness,
                  direction: liftDirection,
                  timestamp: now
                });
                this._log(`ğŸ‘‹ ${correctedHandedness} æŠ¬æ‰‹${liftDirection === 'up' ? 'å‘ä¸Š' : 'å‘ä¸‹'}`, 'success');
              } else {
                // æŒç»­æŠ¬æ‰‹çŠ¶æ€
                const holdDuration = currentTime - handData.gestureStartTime;
                if (holdDuration > 1000) {
                  this._updateHandDisplay(correctedHandedness, `ğŸ‘‹ æŠ¬æ‰‹${liftDirection === 'up' ? 'â†‘' : 'â†“'} (${Math.floor(holdDuration/1000)}s)`, handColor);
                }
              }
            } else {
              // æ²¡æœ‰æ£€æµ‹åˆ°æ–°æ‰‹åŠ¿ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦ä¿æŒä¹‹å‰çš„æ‰‹åŠ¿çŠ¶æ€
              if (shouldKeepGesture) {
                // ä¿æŒä¹‹å‰çš„æ‰‹åŠ¿çŠ¶æ€
                if (handData.gestureState === 'lift') {
                  this._updateHandDisplay(correctedHandedness, `ğŸ‘‹ æŠ¬æ‰‹${handData.liftDirection === 'up' ? 'â†‘' : 'â†“'}`, handColor);
                } else {
                  this._updateHandDisplay(correctedHandedness, 'ğŸ–ï¸ å¼ å¼€', '#0f0');
                }
              } else {
                // æ‰‹åŠ¿çŠ¶æ€ç»“æŸ
                if (handData.gestureState === 'lift') {
                  this._triggerCallback('onLiftEnd', {
                    gesture: 'hand_lift',
                    handedness: correctedHandedness,
                    timestamp: now
                  });
                  this._log(`ğŸ‘‹ ${correctedHandedness} æŠ¬æ‰‹ç»“æŸ`, 'info');
                }
                handData.gestureState = 'open';
                this._updateHandDisplay(correctedHandedness, 'ğŸ–ï¸ å¼ å¼€', '#0f0');
              }
            }

            // å­˜å‚¨å½“å‰å¸§æ•°æ®ç”¨äºä¸‹ä¸€å¸§è®¡ç®—
            handData.lastWy = wristY;
            handData.lastTime = now;

            // ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹ï¼ˆè°ƒè¯•æ¨¡å¼ï¼‰
            if (this.config.DEBUG) {
              this._drawHandLandmarks(landmarks, handColor);
            }
          });
        } else {
          // æ²¡æœ‰æ£€æµ‹åˆ°æ‰‹
          this.state.handCount = 0;
          this.state.lastHandData = {};
        }

        // æ›´æ–°çŠ¶æ€ä¿¡æ¯
        this._updateStatus();
      },

      _correctHandedness: function(handedness) {
        // ä¿®æ­£é•œåƒå¯¼è‡´çš„å·¦å³æ‰‹è¯†åˆ«é—®é¢˜
        return handedness === 'Right' ? 'Left' : 'Right';
      },

      _drawHandLandmarks: function(landmarks, color) {
        if (!this.elements.ctx) return;

        // ç»˜åˆ¶æ‰‹è…•åˆ°æŒ‡å°–çš„è¿çº¿
        const connections = [
          [0, 1], [1, 2], [2, 3], [3, 4],  // æ‹‡æŒ‡
          [0, 5], [5, 6], [6, 7], [7, 8],  // é£ŸæŒ‡
          [0, 9], [9, 10], [10, 11], [11, 12],  // ä¸­æŒ‡
          [0, 13], [13, 14], [14, 15], [15, 16],  // æ— åæŒ‡
          [0, 17], [17, 18], [18, 19], [19, 20]   // å°æŒ‡
        ];

        this.elements.ctx.save();
        this.elements.ctx.scale(-1, 1);
        this.elements.ctx.translate(-this.elements.canvas.width, 0);
        
        // ç»˜åˆ¶è¿æ¥çº¿
        this.elements.ctx.lineWidth = 2;
        this.elements.ctx.strokeStyle = color;
        connections.forEach(connection => {
          const [i, j] = connection;
          this.elements.ctx.beginPath();
          this.elements.ctx.moveTo(
            landmarks[i].x * this.elements.canvas.width,
            landmarks[i].y * this.elements.canvas.height
          );
          this.elements.ctx.lineTo(
            landmarks[j].x * this.elements.canvas.width,
            landmarks[j].y * this.elements.canvas.height
          );
          this.elements.ctx.stroke();
        });

        // ç»˜åˆ¶å…³é”®ç‚¹
        this.elements.ctx.fillStyle = '#0f0';
        landmarks.forEach(landmark => {
          this.elements.ctx.beginPath();
          this.elements.ctx.arc(
            landmark.x * this.elements.canvas.width,
            landmark.y * this.elements.canvas.height,
            3, 0, 2 * Math.PI
          );
          this.elements.ctx.fill();
        });
        
        this.elements.ctx.restore();
      },

      _updateHandDisplay: function(handedness, text, color) {
        const elementId = handedness.toLowerCase() + 'HandIndicator';
        const element = document.getElementById(elementId);
        if (element) {
          element.textContent = text;
          element.style.color = color;
        }
      },

      _resetHandDisplays: function() {
        document.getElementById('leftHandIndicator').textContent = 'ğŸŸ¡ æœªæ£€æµ‹';
        document.getElementById('leftHandIndicator').style.color = '#0f0';
        document.getElementById('rightHandIndicator').textContent = 'ğŸŸ¡ æœªæ£€æµ‹';
        document.getElementById('rightHandIndicator').style.color = '#0f0';
      },

      _updateStatus: function() {
        // æ›´æ–°æ‰‹æ•°æ˜¾ç¤º
        document.getElementById('handsValue').textContent = `${this.state.handCount}/2`;
        
        // æ›´æ–°è¿è¡Œæ—¶é—´
        if (this.state.isRunning) {
          const uptime = Math.floor((performance.now() - this.state.startTime) / 1000);
          document.getElementById('uptimeValue').textContent = `${uptime}s`;
        }
      },

      _updateUI: function() {
        document.getElementById('statusValue').textContent = this.state.isRunning ? 'è¿è¡Œä¸­' : 'æœªå¯åŠ¨';
        document.getElementById('startBtn').disabled = this.state.isRunning;
        document.getElementById('stopBtn').disabled = !this.state.isRunning;
      },

      _updateConfigDisplay: function() {
        document.getElementById('liftThValue').textContent = this.config.LIFT_TH.toFixed(2);
        document.getElementById('gestureHoldValue').textContent = this.config.GESTURE_HOLD_TIME;
      },

      _log: function(message, type = 'info') {
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.style.borderLeftColor = type === 'error' ? '#f00' : type === 'warning' ? '#ff0' : '#0f0';
        entry.style.color = type === 'error' ? '#f00' : type === 'warning' ? '#ff0' : '#0f0';
        entry.innerHTML = `<span style="color: #8f8;">[${new Date().toLocaleTimeString()}]</span> ${message}`;
        this.elements.log.appendChild(entry);
        this.elements.log.scrollTop = this.elements.log.scrollHeight;
      },

      _triggerCallback: function(callbackName, data) {
        if (typeof this.callbacks[callbackName] === 'function') {
          this.callbacks[callbackName](data);
        }
      }
    };

    // é…ç½®æ›´æ–°å‡½æ•°
    function updateConfig() {
      const liftTh = parseFloat(document.getElementById('liftTh').value);
      const gestureHold = parseInt(document.getElementById('gestureHold').value);
      
      GestureAPI.setConfig({
        LIFT_TH: liftTh,
        GESTURE_HOLD_TIME: gestureHold
      });
    }

    // æ¸…ç©ºæ—¥å¿—
    function clearLogs() {
      document.getElementById('logContainer').innerHTML = '';
      GestureAPI._log('æ—¥å¿—å·²æ¸…ç©º', 'info');
    }

    // ç»‘å®šæŠ¬æ‰‹äº‹ä»¶ - è¯†åˆ«åˆ°æŠ¬æ‰‹è‡ªåŠ¨è·³è½¬åˆ°æŒ‡å®šæ˜“ä¼ç§€é“¾æ¥
    GestureAPI.on('onLift', (event) => {
      // é˜²æ­¢é‡å¤è·³è½¬
      if (!GestureAPI.state.hasJumped) {
        GestureAPI._log('æ£€æµ‹åˆ°æŠ¬æ‰‹åŠ¨ä½œï¼Œæ­£åœ¨è·³è½¬åˆ°æŒ‡å®šé“¾æ¥...', 'success');
        GestureAPI.state.hasJumped = true;
        // è·³è½¬æ–°çš„æ˜“ä¼ç§€é“¾æ¥
        window.location.href = 'https://v.eqxiu.com/s/bZaOGBmZ?bt=yxy&eip=true';
      }
      
      if (GestureAPI.config.DEBUG) {
        console.log('æŠ¬æ‰‹äº‹ä»¶:', event);
      }
    });

    // åˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', function() {
      GestureAPI._updateConfigDisplay();
      GestureAPI._log('ç³»ç»Ÿå°±ç»ªï¼Œç‚¹å‡»å¼€å§‹æ£€æµ‹', 'info');
      GestureAPI._log('ğŸ’¡ è¯†åˆ«åˆ°æŠ¬æ‰‹å°†è‡ªåŠ¨è·³è½¬åˆ°æŒ‡å®šæ˜“ä¼ç§€é“¾æ¥', 'info');
    });

    window.GestureAPI = GestureAPI;
    window.updateConfig = updateConfig;
    window.clearLogs = clearLogs;
  </script>
</body>
</html>